<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nucleosome Occupancy (Browser)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #f9fafb;
      --text: #111827;
      --muted: #6b7280;
      --accent: #2563eb;
      --grid: #e5e7eb;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 16px;
    }

    header {
      padding: 16px 20px;
      background: var(--panel);
      border-bottom: 1px solid var(--grid);
    }

    h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .container {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      padding: 0 20px 20px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 10px;
    }

    .card h2 {
      font-size: 14px;
      margin: 0;
      padding: 12px 14px;
      border-bottom: 1px solid var(--grid);
      color: var(--muted);
      font-weight: 600;
    }

    .card .content {
      padding: 12px 14px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin: 12px 0 6px;
    }

    textarea,
    input,
    button {
      width: 100%;
      box-sizing: border-box;
    }

    textarea,
    input {
      background: #ffffff;
      border: 1px solid var(--grid);
      color: var(--text);
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 13px;
    }

    textarea {
      min-height: 140px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    button {
      margin-top: 14px;
      background: var(--accent);
      border: none;
      color: #ffffff;
      font-weight: 700;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: filter .15s ease-in-out;
      font-size: 14px;
    }

    button:hover {
      filter: brightness(1.05);
    }

    button:disabled {
      background: #9ca3af !important;
      cursor: not-allowed !important;
      filter: none !important;
    }

    button:disabled:hover {
      filter: none !important;
    }

    .note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    canvas {
      background: #ffffff;
      border-radius: 10px;
    }

    /* Fix chart height to about half the viewport */
    #chart {
      height: 50vh;
      width: 100%;
      display: block;
    }

    .error {
      color: #b91c1c;
      font-size: 12px;
      margin-top: 8px;
      white-space: pre-wrap;
    }

    .footer {
      font-size: 12px;
      color: var(--muted);
      padding: 0 20px 20px;
    }

    .computing {
      cursor: wait !important;
    }

    .computing *,
    .computing *:hover {
      cursor: wait !important;
    }

    html.computing,
    html.computing * {
      cursor: wait !important;
    }
  </style>
</head>

<body>
  <header>
    <h1>Nucleosome Occupancy</h1>
  </header>
  <div class="container">
    <div class="card">
      <h2>Inputs</h2>
      <div class="content">
        <div id="uploadName" class="note"></div>
        <input id="upload" type="file" accept=".fa,.fasta,.fna,.txt,text/plain,.seq,.dna" style="display:none" />
        <button id="uploadBtn">Upload FASTA/DNA</button>
        <label for="sequence">DNA sequence (A/C/G/T)</label>
        <textarea id="sequence" spellcheck="false" placeholder="Paste or type sequence here..."></textarea>
        <div class="row">
          <div>
            <label for="period">Period (bp)</label>
            <input id="period" type="number" step="0.1" value="10.1" />
          </div>
          <div>
            <label for="footprint">Footprint (bp)</label>
            <input id="footprint" type="number" step="1" value="147" />
          </div>
          <div>
            <label for="amplitude">Amplitude (B)</label>
            <input id="amplitude" type="number" step="0.01" value="0.2" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="chemicalPotential">Chemical potential (kT)</label>
            <input id="chemicalPotential" type="number" step="0.1" value="-8.5" />
          </div>
          <div></div>
          <div></div>
        </div>
        <button id="runBtn">Run</button>
        <div id="loading" style="display: none; color: #2563eb; font-weight: bold; margin: 10px 0;">
          ðŸ”„ Computing nucleosome occupancy...
        </div>
        <button id="downloadBtn" disabled>Download CSV</button>
        <div id="error" class="error"></div>
      </div>
    </div>

    <div class="card">
      <h2>Output</h2>
      <div class="content">
        <canvas id="chart"></canvas>
      </div>
    </div>
  </div>
  <div class="footer">This is the code described in "Sequence-based prediction of single nucleosome positioning and
    genome-wide nucleosome occupancy" (<a
      href="https://doi.org/10.1073/pnas.1205659109">https://doi.org/10.1073/pnas.1205659109</a>).

    .</div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- Pyodide for Python in the browser -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
  <script>
    const elSeq = document.getElementById('sequence');
    const elMu = document.getElementById('chemicalPotential');
    const elFoot = document.getElementById('footprint');
    const elAmp = document.getElementById('amplitude');
    const elPer = document.getElementById('period');
    const elRun = document.getElementById('runBtn');
    const elErr = document.getElementById('error');
    const ctx = document.getElementById('chart');
    const elDownload = document.getElementById('downloadBtn');
    const elUpload = document.getElementById('upload');
    const elLoading = document.getElementById('loading');
    const elUploadBtn = document.getElementById('uploadBtn');
    const elUploadName = document.getElementById('uploadName');

    // Style upload as button and show filename
    let isFileUpload = false; // Flag to track if change is from file upload
    if (elUploadBtn && elUpload) {
      elUploadBtn.addEventListener('click', () => elUpload.click());
      elUpload.addEventListener('change', async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        // Disable run button while loading file (but keep text as "Run")
        elRun.disabled = true;
        elDownload.disabled = true;

        isFileUpload = true; // Set flag before changing sequence
        let seq = '';
        if (file.name.toLowerCase().endsWith('.dna')) {
          // Handle SnapGene .dna files - extract sequence from binary format
          try {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);

            // SnapGene .dna files have a specific structure
            // Look for sequence data which is often stored as plain text within the binary file
            let foundSequence = '';

            // Method 1: Look for continuous stretches of A, C, G, T characters
            let currentSequence = '';
            for (let i = 0; i < uint8Array.length; i++) {
              const char = String.fromCharCode(uint8Array[i]);
              if (/[ACGTacgt]/.test(char)) {
                currentSequence += char.toUpperCase();
              } else {
                // If we hit a non-DNA character, check if we have a substantial sequence
                if (currentSequence.length > 50) { // Minimum sequence length threshold
                  if (currentSequence.length > foundSequence.length) {
                    foundSequence = currentSequence;
                  }
                }
                currentSequence = '';
              }
            }
            // Check the last sequence too
            if (currentSequence.length > 50 && currentSequence.length > foundSequence.length) {
              foundSequence = currentSequence;
            }

            // Method 2: If Method 1 didn't find a good sequence, try looking for length-prefixed data
            if (foundSequence.length < 100) {
              for (let i = 0; i < uint8Array.length - 8; i++) {
                // Look for 4-byte length followed by sequence data
                const len1 = (uint8Array[i] << 24) | (uint8Array[i + 1] << 16) | (uint8Array[i + 2] << 8) | uint8Array[i + 3];
                const len2 = (uint8Array[i + 3] << 24) | (uint8Array[i + 2] << 16) | (uint8Array[i + 1] << 8) | uint8Array[i];

                for (const possibleLength of [len1, len2]) {
                  if (possibleLength > 50 && possibleLength < 1000000 && i + 4 + possibleLength <= uint8Array.length) {
                    const candidateSeq = String.fromCharCode(...uint8Array.slice(i + 4, i + 4 + possibleLength));
                    // Check if this looks like a DNA sequence
                    const dnaRatio = (candidateSeq.match(/[ACGTacgt]/g) || []).length / candidateSeq.length;
                    if (dnaRatio > 0.9 && candidateSeq.length > foundSequence.length) {
                      foundSequence = candidateSeq.toUpperCase().replace(/[^ACGT]/g, '');
                    }
                  }
                }
              }
            }

            if (foundSequence.length > 0) {
              seq = foundSequence;
            } else {
              throw new Error('Could not find sequence data in .dna file');
            }

          } catch (error) {
            elErr.textContent = 'Error reading .dna file: ' + error.message;
            // Restore run button on error
            elRun.disabled = false;
            return;
          }
        } else {
          // Handle text files (FASTA, etc.)
          const text = await file.text();
          // Parse FASTA: remove any header lines starting with '>', keep only sequence lines
          const lines = text.split(/\r?\n/);
          seq = lines
            .filter(line => line.trim() && !line.startsWith('>'))
            .join('')
            .toUpperCase()
            .replace(/U/g, 'T');
        }

        elSeq.value = seq;
        // Set filename AFTER setting sequence to avoid it being cleared by input event
        elUploadName.textContent = file.name;
        // Disable download until rerun
        elDownload.setAttribute('disabled', '');

        // Automatically run computation after uploading file
        if (seq.length > 0) {
          // Small delay to ensure UI updates, then run computation
          setTimeout(async () => {
            await run();
          }, 100);
        } else {
          // If no sequence was loaded, re-enable run button
          elRun.disabled = false;
        }

        isFileUpload = false; // Reset flag after upload complete
        // Clear the file input value so the same file can be uploaded again
        elUpload.value = '';
      });
      // Clear filename label if sequence edited manually (not from file upload)
      elSeq.addEventListener('input', () => {
        if (!isFileUpload) {
          elUploadName.textContent = '';
        }
        // Disable download button when sequence changes
        elDownload.disabled = true;
      });
    }

    // Disable download button when any input changes
    function disableDownload() {
      elDownload.disabled = true;
    }

    elSeq.addEventListener('input', disableDownload);
    elMu.addEventListener('input', disableDownload);
    elFoot.addEventListener('input', disableDownload);
    elAmp.addEventListener('input', disableDownload);
    elPer.addEventListener('input', disableDownload);

    // Seed example
    elSeq.value = 'CTGGGGTTATACTTTAATAGGAAGGGGGGAACAAGTATACTTACAGAGCTGTCTATATAACGGTCATGAAATTAGGGTTCACCCGAGGAAGCCCTTTTTGCGAGGCCCGTACCGAAGCCGCACCGGACTTTTGTGGGGCAGTCCTCCCATCCACATGCTGCCGGAGTTAAATCTTTCTCACTTTTCCACGCGATTGAGCACGTGGCTGGTGAATACTTTTGACTATTAGTCCTCTTTGCACATCAATTGGGGAGATTCCTGTGTTTCCAAGGTCAAAGACGAGGGTCAACCTCAAAAAGTGGAATCACACGATATAATATGTTGCAAACTAGTTGGTAAAACGTCCACTCCTGGATCGACTGGGCCTACCTATTCACCTCACTTGGTTAACTCCGTTTGGGACAGTTTCTCCTCACCCACGTCATTTGCGGTGAGAACCTACGATTTTTTCCAAGGTCGTAACTCGACGTTAACCCGGCCGAACAGCACCCAGCGCCGCTGAGACCTCAGTTAAAATTCCTATAATGGTTCGGATTCGGTCGTACGATAGTCATCGGACTAACTTTTCCTCTACGGAGTGCAGAGCTCCCCATGCCCGATAAGCAGGTAGTGATTGTACCTCAGACTGGTGTTACTCCACCCTTTGGCTATCCGCGCGTTTGAGAATCGTTCATTCGCAAACTAGTTTATGTGTCGACCGCATGCTGCAAAGTACCTAAAATGGGCTCATAACCCAACCGCAGCAGAGACATGTCCCCGAGGCTTTTGATTCAAAGGTCGGGACACTAAAGATTAATCCATCCAAACATAATGGGTAATGCCACTATGGATGTTCTTTGTTCTGAACCTCTCGGGTCGTGACTTAATGCGTCCACCTTACCATTAGTACACCATTGTCAATACAAGCACTGAGTGCTCGCCCTTCTACAGGATGTATATATCTGACACGTGCCTGGAGACTAGGGAGTAATCCCCTTGGCGGTTAAAACGCGGGGGACAGCGCGTACGTGCGTTTAAGCGGTGCTAGAGCTGTCTACGACCAATTGAGCGGCCTCGGCACCGGGATTCTCCAGATGCCGCCACTACCGACACCCCGTAACTCCTGGGAGGGTATTCAAGGGCCCTTCTGATGAATACCATTGTGCTTATTTGTGTTCCGATTTTAAGTTAGCCCGCTATCTGGACAGTAATGAAACACCAGTGGTTAACATGCCAAATTATGTATTAGCTCTCTTAGGAAGTCACGGGGGCGAGGGGGTGTAGCAGCCTATGTGGTTTTGGTCGTTCTTAGGAACGCACATTCACTGCGATCTCACAGTTCACTACGCGGTATTCGATAGAACTATGGCAGAAGTGTCCTGATCGCTGATAATTTTCCGGTTTATTGCAACGGGGAACTGTTGCTCAGGTCACGGCTAACGGTATCTTCGAAATTCGACTGTAGGTTGATCTCCGGCGATGTAGAGTTGGTTATGTAGATCCACCCTTAGAGGTTTCGCCTATGGGCCCCGTTTGCAATTTGGTTGTCACTAGGGAATGCACATTATAACAAAACCTGTCCACGGGGGGGTCCATTTAGCGCGGTTCTCATATGGCGACATATATTGGCCACTATGCGGGAATTGAAAGAGTGGCCGAAGGTAGGTCCGTTAATCCCCCGACAAAATGGTACCCGTTTCATTGCTGGCTGAGTCAGAATTAGGATAGTAGTCGATGGGTACGGTGCATTTAAGCTACCGACGCGGTCACCTGATCCCAGGCGATCACAGACAACGGCACGGGATCCGTGCAAACACAGCCTATTTCGGTCGCCATMGCCATTCACGAAGGCCCTCAACTTCTCTACAGGTTCACGGTCGATATAACCTTGCAGCGAGCCGCTTCCCACGTTCTGACACTTAGGGTATTCTTCGCGAACGGAATTGGAGCTACGGCCAGCTAGCGACGTAGGTCCGTCGAACCACTACCTACCCAACATGGAGCCGTAACATTGATCTGA'
    let chart;
    function render(occupancy) {
      const labels = Array.from({ length: occupancy.length }, (_, i) => i);
      // Determine tick interval based on plot size
      let interval = 100;
      if (labels.length > 10000) interval = 1000;
      else if (labels.length > 2000) interval = 500;
      const ds = { label: 'Occupancy', data: occupancy, borderColor: '#2563eb', backgroundColor: 'rgba(37, 99, 235, 0.3)', fill: true, borderWidth: 2, pointRadius: 0 };
      // Enable/disable download based on occupancy size
      if (Array.isArray(occupancy) ? occupancy.length > 0 : (occupancy?.length ?? 0) > 0) {
        elDownload.removeAttribute('disabled');
      } else {
        elDownload.setAttribute('disabled', '');
      }
      if (chart) { chart.data.labels = labels; chart.data.datasets = [ds]; chart.options.scales.x.ticks.callback = (value, index) => (index % interval === 0 ? index : ''); chart.update(); return; }
      chart = new Chart(ctx, {
        type: 'line', data: { labels, datasets: [ds] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'i (bp)', color: '#6b7280' },
              ticks: {
                color: '#6b7280',
                autoSkip: false,
                callback: (value, index) => (index % interval === 0 ? index : '')
              },
              grid: { display: false }
            },
            y: {
              min: 0,
              max: 1,
              title: { display: true, text: 'Occupancy', color: '#6b7280' },
              ticks: { color: '#6b7280' },
              grid: { display: false }
            }
          },
          plugins: {
            legend: { display: false }
          }
        }
      });
    }

    let pyReady = (async () => {
      const pyodide = await loadPyodide();
      await pyodide.loadPackage(['numpy']);

      // Provide the Python core (trimmed to essentials and mirrored from your file)
      const pyCode = `
import re, random
import numpy as nu
from dataclasses import dataclass

FOOTPRINT = 147
SMOOTH_WINDOW = 10
OCCUPANCY_KERNEL = 146

_ASCII_TO_IDX = nu.full(256, -1, dtype=nu.int8)
_ASCII_TO_IDX[ord('A')] = 0
_ASCII_TO_IDX[ord('C')] = 1
_ASCII_TO_IDX[ord('G')] = 2
_ASCII_TO_IDX[ord('T')] = 3

@dataclass(frozen=True)
class NucPositionResult:
    energy_raw: nu.ndarray
    energy_smoothed: nu.ndarray
    dyad_probability: nu.ndarray
    occupancy: nu.ndarray

def CleanSeq(dna: str) -> str:
    dna = dna.upper().replace('U','T')
    return re.sub(r"[^GATC]", "", dna)

def encode_seq(seq: str) -> nu.ndarray:
    b = nu.frombuffer(seq.encode('ascii'), dtype=nu.uint8)
    return _ASCII_TO_IDX[b]

def getweight(w: int, p: float, b: float) -> nu.ndarray:
    x = nu.arange(w, dtype=nu.float64)
    s = b * nu.sin(2 * nu.pi * x / p)
    weights = nu.empty((4,4,w), dtype=nu.float64)
    weights[0,0] = 0.25 + s
    weights[0,1] = 0.25 - s/3
    weights[0,2] = 0.25 - s/3
    weights[0,3] = 0.25 - s/3
    weights[1,0] = 0.25
    weights[1,1] = 0.25
    weights[1,2] = 0.25
    weights[1,3] = 0.25
    weights[2,0] = 0.25 + s/3
    weights[2,1] = 0.25 - s
    weights[2,2] = 0.25 + s/3
    weights[2,3] = 0.25 + s/3
    weights[3,0] = 0.25 + s
    weights[3,1] = 0.25 - s
    weights[3,2] = 0.25 - s
    weights[3,3] = 0.25 + s
    return weights

def calcE(seq: str, w: int, amplitude: float, period: float) -> nu.ndarray:
    idx = encode_seq(seq)
    L = idx.size
    num_win = L - w
    if num_win <= 0:
        return nu.array([], dtype=nu.float64)
    weights = getweight(w, period, amplitude)
    log_weights = nu.log(nu.clip(weights, 1e-300, None))
    log_p_f = nu.zeros(num_win, dtype=nu.float64)
    log_p_r = nu.zeros(num_win, dtype=nu.float64)
    i = nu.arange(num_win)
    for s in range(w):
        prev_f = idx[i + s - 1]
        curr_f = idx[i + s]
        log_p_f += log_weights[prev_f, curr_f, s]
        a = idx[i + w - s]
        b = idx[i + w - s - 1]
        rprev = 3 - a
        rcurr = 3 - b
        log_p_r += log_weights[rprev, rcurr, s]
    p_f = nu.exp(log_p_f) * (4.0 ** w)
    p_r = nu.exp(log_p_r) * (4.0 ** w)
    p_r = nu.roll(p_r, -1)
    E = (p_r * nu.log(p_r) + p_f * nu.log(p_f)) / (p_r + p_f)
    return E

def smooth(x: nu.ndarray, window_len: int) -> nu.ndarray:
    if window_len <= 1 or x.size == 0:
        return x
    s = nu.r_[x[window_len - 1 : 0 : -1], x, x[-1:-window_len:-1]]
    w = nu.ones(window_len, dtype=nu.float64)
    y = nu.convolve(w / w.sum(), s, mode='valid')
    return y[len(x[window_len - 1 : 0 : -1]) : len(x[window_len - 1 : 0 : -1]) + len(x) + 1]

def vanderlick(Energy: nu.ndarray, mu: float, footprint: int) -> nu.ndarray:
    E_out = Energy - mu
    n = E_out.size
    forward = nu.zeros(n, dtype=nu.float64)
    sum_prev = 0.0
    for i in range(n):
        forward[i] = nu.exp(E_out[i] - sum_prev)
        sum_prev += forward[i]
        if i >= footprint:
            sum_prev -= forward[i - footprint]
    backward = nu.zeros(n, dtype=nu.float64)
    r_forward = forward[::-1]
    sum_prod = 0.0
    for i in range(n):
        backward[i] = 1.0 - sum_prod
        sum_prod += r_forward[i] * backward[i]
        if i >= footprint:
            sum_prod -= r_forward[i - footprint] * backward[i - footprint]
    return forward * backward[::-1]

def CalcNucPositions(sequence: str, w: int, chemical_potential: float, amplitude: float, period: float) -> NucPositionResult:
    sequence = CleanSeq(sequence)
    energy_raw = calcE(sequence, w, amplitude, period)
    energy_smoothed = smooth(energy_raw, SMOOTH_WINDOW)
    dyad_probability = vanderlick(energy_smoothed, chemical_potential, w)
    left_pad = (w + 1) // 2
    right_pad = w // 2
    dyad_probability = nu.concatenate((nu.zeros(left_pad, dtype=nu.float64), dyad_probability, nu.zeros(right_pad, dtype=nu.float64)))
    occupancy = nu.convolve(dyad_probability, nu.ones(OCCUPANCY_KERNEL, dtype=nu.float64), mode='same')
    return NucPositionResult(energy_raw, energy_smoothed, dyad_probability, occupancy)
`;
      pyodide.runPython(pyCode);
      return pyodide;
    })();

    let lastResult = null;
    async function run() {
      try {
        // Disable both buttons and show computing state
        elRun.disabled = true;
        elRun.textContent = 'Computing...';
        elDownload.disabled = true;
        elLoading.style.display = 'block';
        elErr.textContent = '';

        const py = await pyReady;
        const seq = (elSeq.value || '').toString();
        const mu = parseFloat(elMu.value);
        const w = Math.max(1, Math.floor(parseFloat(elFoot.value)) || 147);
        const amp = parseFloat(elAmp.value);
        const per = parseFloat(elPer.value);
        if (seq.length < w + 2) { throw new Error(`Sequence too short for footprint w=${w}. Provide at least w+2 bases.`); }

        // call Python CalcNucPositions
        py.globals.set('JS_SEQ', seq);
        py.globals.set('JS_W', w);
        py.globals.set('JS_MU', mu);
        py.globals.set('JS_AMP', amp);
        py.globals.set('JS_PER', per);
        py.runPython(`res = CalcNucPositions(JS_SEQ, JS_W, JS_MU, JS_AMP, JS_PER)`);

        // fetch arrays we might want to export
        const occ = py.runPython(`res.occupancy.tolist()`);
        const dyad = py.runPython(`res.dyad_probability.tolist()`);
        lastResult = { occupancy: occ, dyad };
        render(occ);

        // Enable download button only after successful computation
        elDownload.disabled = false;
      } catch (e) {
        console.error(e);
        elErr.textContent = String(e?.message || e);
        // Keep download button disabled on error
        elDownload.disabled = true;
      } finally {
        // Always restore run button
        elLoading.style.display = 'none';
        elRun.disabled = false;
        elRun.textContent = 'Run';
        console.log('Run function completed, buttons should be enabled');
      }
    }

    function downloadCSV() {
      try {
        if (!lastResult) { throw new Error('Run the model first'); }

        // Determine suggested filename
        let suggestedFilename = 'nucleosome_occupancy.csv';
        const uploadedFilename = elUploadName.textContent.trim();

        if (uploadedFilename) {
          // Remove extension and add .csv
          const nameWithoutExt = uploadedFilename.replace(/\.[^/.]+$/, '');
          suggestedFilename = nameWithoutExt + '.csv';
        }

        // Ask user for filename
        const filename = prompt('Enter filename for CSV export:', suggestedFilename);
        if (!filename) return; // User cancelled

        // Ensure filename ends with .csv
        const finalFilename = filename.endsWith('.csv') ? filename : filename + '.csv';

        const len = lastResult.occupancy.length;
        const rows = ['i;occupancy;dyad_probability'];
        for (let i = 0; i < len; i++) {
          const o = lastResult.occupancy[i] ?? '';
          const d = lastResult.dyad?.[i] ?? '';
          rows.push(`${i};${o};${d}`);
        }
        // Add BOM for better Excel compatibility
        const csvContent = '\uFEFF' + rows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = finalFilename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      } catch (e) { elErr.textContent = String(e?.message || e); }
    }

    elRun.addEventListener('click', run);
    elDownload.addEventListener('click', downloadCSV);
    // Auto-run once after Pyodide is loaded
    (async () => { try { await pyReady; await run(); } catch (e) { elErr.textContent = String(e?.message || e); } })();
  </script>
</body>

</html>